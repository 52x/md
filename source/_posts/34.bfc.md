title: CSS 之 BFC 详解及实战
date: 2017-3-14
tags: [CSS]
---
## 什么是 BFC ？
BFC，是Block formatting contexts（块级格式化上下文）的缩写，是 CSS2.1 提出来的一个重要概念。

## 前言
要了解 BFC 必需先了解 CSS 的定位方案。定位方案是用于控制元素的布局，在 CSS2.1 中，有三种定位方案——普通流 (Normal Flow) 、浮动 (Floats) 和绝对定位 (Absolute Positioning) 。

0. 普通流(Normal Flow)
在普通流中，元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位。

0. 浮动 (Floats)
在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或右边偏移，其效果与印刷排版中的文本环绕相似。

0. 绝对定位 (Absolute Positioning)
在绝对定位布局中，元素会整体脱离普通流，因此绝对定位元素不会对其兄弟元素造成影响（这点与浮动元素会影响兄弟元素不同），而元素具体的位置由绝对定位的坐标决定。

BFC 属于普通流，因此它对兄弟元素也不会造成什么影响。

## 描述

首先 BFC 是一个独立的布局环境，内部元素的布局和定位是不受外界的影响的。并且在一个 BFC 中，块级盒与行内盒（由一行中所有的内联元素所组成）都会垂直的沿着其父元素的边框排列。
从样式上看，具有 BFC 的元素与普通的容器没有什么区别，但是从功能上，具有 BFC 的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器没有的一些特性。
简单来说，BFC 就是一种属性，这种属性会影响着元素的定位以及与其兄弟元素之间的相互作用。
它在 CSS2.1 首次提出，CSS3 对这个规范做了改动，称之为：flow root，并且对触发条件进行了进一步说明。

## 触发条件（参考 MDN）
0. 根元素或其它包含它的元素
0. 浮动 float:除了 none 以外的值
0. 绝对定位 position:absolute、fixed
0. 块元素 overflow:除了 visible 以外的值（hidden、auto、scroll）
0. 行内块元素 display:inline-block
0. 表格元素 display:table-cell、table-caption
0. 弹性盒子 flex boxes: (元素具有display: flex 或 inline-flex)
0. display: flow-root

一个块格式化上下文包括创建它的元素内部所有内容（不包括创建元素本身），除了会创建新的块格式化上下文的元素。

块格式化上下文对于定位 float 与清除浮动 clear 很重要。定位和清除浮动的样式规则只适用于处于同一块格式化上下文内的元素。浮动不会影响其它块格式化上下文中元素的布局，并且清除浮动只能清除同一块格式化上下文中在它前面的元素的浮动。

> 注：display:table 本身并不会创建 BFC，但是它会产生匿名框(anonymous boxes)，而匿名框中的 display:table-cell 可以创建新的 BFC，换句话说，触发块级格式化上下文的是匿名框，而不是 display:table。所以通过 display:table 和 display:table-cell 创建的BFC效果是不一样的。

## 特性

0. BFC 会阻止外边距叠加
当两个相邻的块级元素在同一个 BFC 中时，它们之间垂直方向的外边距会发生叠加，叠加后的外边距的高度等于两个发生叠加的外边距中的较大者。
一般发生在相邻的兄弟元素、块级父元素与其第一个/最后一个子元素间。
换句话说，如果这两个相邻的块级元素不属于同一个 BFC，那么它们的外边距就不会叠加。

0. BFC 会阻止元素被浮动元素覆盖
浮动元素的块状兄弟元素会无视浮动元素的位置，尽量占满一整行，这样就会被浮动元素覆盖，为该兄弟元素触发 BFC 后可以阻止这种情况的发生。
因为根据规定，一个 BFC 的边框不能和它里面的元素的外边距重叠。这就意味着浏览器将会给 BFC 创建隐式的外边距来阻止它和浮动元素的外边距叠加。由于这个原因，当给一个挨着浮动元素的 BFC 添加负的外边距时将会不起作用。

0. BFC 可以包含浮动的元素
BFC 会根据子元素的情况自动适应高度，即使其子元素中包括浮动元素。计算BFC的高度时，浮动元素也参与计算。
创建了 BFC 的元素就是一个独立的盒子，里面的子元素不会在布局上影响外面的元素，反之亦然，同时 BFC 仍然属于文档中的普通流。
我们闭合（清除）浮动就是应用了这个特性，产生 BFC 以包含浮动元素。


## 应用

### 防止外边距叠加
外边距叠加 或者叫 外边距合并（margin collapsing）：当两个垂直外边距相遇时，会合并为一个外边距。合并后的外边距的高度等于两个发生合并的外边距中的较大者。
0. 父元素加 `padding-top: 1px;` //此非触发BFC的方式
0. 父元素加 `overflow: hidden;`
0. 父元素加
```css
:before {
  display: table;
  content: " ";
}
```
0. 兄弟元素加 `display: inline-block`

### 布局
可以用于自适应布局。
相比于流式布局有如下优势：
0. 自适应内容由于封闭，更健壮，容错性强。比方说，内部clear:both不会与兄弟float产生矛盾。而纯流体布局，clear:both会让后面内容无法和float元素在一个水平上，产生布局问题。
0. 自适应内容自动填满浮动以为区域，无需关心浮动元素宽度，可以整站大规模应用。而纯流体布局，需要大小不确定的margin/padding等值撑开合适间距，无法CSS组件化。

理论上，任何 BFC 元素和浮动元素相邻时，都可以实现自动填充的自适应布局。
但是，由于绝大多数的触发BFC的属性自身有一些古怪的特性，所以，实践开发中，能具有实用价值的属性并不多：
0. float:left 浮动元素本身 BFC 化，然而浮动元素有破坏性和包裹性，失去了元素本身的流体自适应性，因此，无法用来实现自动填满容器的自适应布局。不过，其因兼容性还算良好，与堆积木这种现实认知匹配，上手简单，因此在旧时代被大肆使用，也就是常说的“浮动布局”，也算阴差阳错开创了自己的一套布局。
0. position:absolute 脱离文档流，无法使用
0. overflow:hidden 比上述的好些，仅仅是溢出剪裁。在局部确定没有被裁剪的情况下可以使用，不适合全站或大规模使用。
0. display:inline-block 有包裹性，即元素尺寸会随着内容膨胀或者收缩，没法实现流体自适应布局。只是在 IE6/7 下，block 元素设置后会自适应容器的可用宽度显示，实现流体自适应布局。
0. display:table-cell 让元素表现得像单元格一样，IE8+ 支持。跟前者一样，会随内部元素的宽度显示。但是，单元格有个神奇的特性，就是宽度值设置再大，实际宽度也不会超过容器的宽度。
    因此，如果这个 BFC 元素宽度设置很大，那其实就跟 block 水平元素自动适应容器宽度效果一模一样了。
    .bfc-content {
        display: table-cell; width: 999em;
    }
    目前看上去还不错，就是有两点制约：一是 IE8+ 兼容；二是遇到连续英文字符无法换行（可以嵌套table-layout:fixed解决）。
0. display:table-caption 无法使用

最后结论如下：
0. overflow:auto/hidden IE7+
0. display:inline-block IE6/7
0. display:table-cell IE8+
```css
.sider {
    float: left;
    width: 200px;
}
.content {
    display: table-cell;
    width: 999em;
    *display: inline-block;
    *width: auto;
}
```
### 清除浮动
这是 BFC 的最典型应用
0. 让父元素触发BFC
```css
.parent {
    overflow: hidden; /*可能会隐藏溢出元素*/
}
.parent {
    display:table; /* 本身并不会创建 BFC，但是它会产生匿名框(anonymous boxes)，而匿名框中的 display:table-cell 可以创建新的 BFC */
}
```
0.  父元素末尾添加额外的子级元素
```css
.clear {
    clear:both;
    height: 0;
    font: 0/0;
}
```
0. 使用伪元素
```css
.clear:before, .clear:after {
    display: table; /* 用 table 的原因是用于 :before 可以触发 BFC，从而避免父级与第一个子级元素外边界合并。 */
    content: " ";
}
.clear:after {
    clear: both;
}
```
