title: 完美C++(第五版)读书笔记
date: 2015-02-19 22:35:37
categories: iOS
tags: [swift]
---
# 第1章 C++基础
<!-- more -->
## 变量、表达式及赋值语句
### 类型转换
C++共有4-6种不同的类型转换。旧的类型转换有两种使用方式，而最近的新标准给出了四种新的类型转换方式。
四种新的类型转换方法如下所示：
	static_cast<Type>(Expression)
	const_cast<Type>(Expression) 
	dynamic_cast<Type>(Expression)
	reinterpret_cast<Type>(Expression)
两种旧的
	double(42)
	(double)42
### 自增自减的求值顺序（trick）
	(n+2)*(++n)+5
不要将运算符优先级与表达式的求值顺序混为一谈，子表达式++n和(n+2)的计算顺序并不确定，取决于编译器

## cout、cerr
格式化浮点数如下：
	cout.setf(ios::fixed)
	cout.setf(ios::showpoint)
	cout.precision(2)
cerr输出到标准错误输出流（一般是控制台屏幕）

***
# 第2章 流程控制
## 文件输入简介
ifstream读取文件

***
# 第3章 函数基础
## 函数设计
1.前提条件（precondition）、运行结果（postcondition）
2.过程抽象、黑箱

## 作用域规则
语句块
嵌套作用域

***
# 第4章 函数与重载
形参是一种占位符，函数调用时，由函数的实参来替换。
## 参数
传值参数
引用传递调用机制详解

## 重载与默认实参
### 重载解析的规则
简单地说：
1. 精确匹配
2. 自动类型转换后匹配

详细的说：
1. 精确匹配
2. int或float通过提升实现匹配
3. 通过预定义类型的其他转换实现匹配
4. 通过用户定义的类型进行转换实现匹配
5. 使用省略号进行匹配
### 默认参数
必须从右开始省略实参

## 函数的测试和调试
assert宏：#define NDEBUG关闭assert调用
占位程序和驱动程序

***
# 第5章 数组
数组参数既不是值传递调用参数，也不是引用传递调用参数，它是一种新的参数传递类型。
数组占用内存中的一部分连续空间。数组首地址、存储类型、数组大小三要素。
程序中个函数的const修饰数组风格要统一，防止嵌套调用问题。

***
# 第6章 结构体和类
## 结构体的初始化
Date dueDate={12,31,2012}; 如果给出的初始化值多于结构体成员的数量，那么就会出错。允许初始值少于结构体成员的数量，按顺序初始化，未初始化的使用默认值。
## 作用域运算符::
作用域运算符和类名一起使用，而点运算符则和对象名一起使用。
## 封装
通过类来隐藏成员函数以及数据的实现细节，只暴露相关的使用接口。通常将成员变量都设置为私有的，而将大多数成员函数都设置为公有的。
## Set & get
## 接口和实现分离
接口包含两个部分：注释和公有成员函数。类的实现就是具体实现该类接口的C++代码。
## 结构体与类的区别
结构体通常不包含成员函数，并且所有的成员变量也都是共有的。类的默认权限是私有的，而结构体的默认权限是公有的。

***
# 第7章 构造函数及其他工具
## 构造函数
构造函数是放在类的公有部分声明的，不能直接调用构造函数。
### 初始化列表
DayofYear::DayofYear(int monthValue,int dayValue):month(monthValue),day(dayValue){}
### 无参构造函数
DayofYear date3(); 不需要加括号，编译器会认为该语句是函数定义。
### 默认构造函数
无参构造函数被称为默认构造函数，编译器会自动生成。如果类中定义了构造函数，编译器就不用自动添加默认构造函数。因此只要手动编写构造函数，就一定要写上默认构造函数，否则会缺失默认构造函数。

## const修饰符
const使用的一致性

## inline内联函数
在编译时，内联函数的代码会被直接插入到每个调用内联函数的地方，从而减少函数调用的开销。但是将类的定义和实现混为一谈，违背了OOP的封装原则，因此大多数编译器的内敛函数只能在定义它的源文件中使用。

## static静态成员
被所有对象共享的变量成为静态变量，一个静态变量只能被初始化一次。
静态成员函数，它的定义不能使用任何与被调用对象有关的内容，关键字static只在静态成员函数的声明中出现，定义中不出现。

## 向量

***
# 第8章 运算符重载、友元和引用
## 运算符重载
x+7本应表示为+(x,7)，运算符是语法糖。
陷阱：重载&& ||等运算符后，原有的短路求值性质消失，改为完全求值。

运算符重载有普通运算符重载和成员函数重载。作为成员函数重载可以避免使用取值和赋值函数，从而提高效率。但是“构造函数的自动类型转换”概念，使得有时必须用普通运算符重载。baseAccount+25，本质上是先将25转换为Money类，在调用+运算。但是25+baseAccount如果使用成员函数的方式来重载+号，25不是类，Money类的构造函数可以对参数进行自动的类型转换，却不能对调用对象进行类型转换。兼顾普通运算符重载和成员函数重载优点的方法就是使用友元。

## 友元
一个函数可以作为多个类的友元函数。使用友元类时，往往需要提前声明。例如

## 运算符重载规则
只能以成员函数的方式进行重载：= [] -> ()
不可以创建新的运算符，只能对已有的运算符进行重载。
不可改变运算符的参数个数，例如将一元运算符重载为二元运算符。
重载后的运算符运算优先级不变。
以下运算符不能被冲在 . :: sizeof ?: .*

## 引用和其他重载运算符
### 左值右值
如果希望函数的返回值可以作为左值，那么必须返回一个引用类型。

### 重载>>和<<
friend ostream& operator <<(ostream& outs,const Money& amount);

### 如何使用返回值类型
函数中有四种不同的方式返回一个类型为T的返回值
1. 返回一般值 T f()
2. 返回一个常量值， const T f()
3. 返回一个引用， T& f()
4. 返回一个常量引用，const T& f()
简单类型使用const修饰无意义；
返回值作为左值或返回一个引用，必须返回引用类型T& f()；
返回一个常量值，使用const T f()

### 重载自增、自减运算符
intPair operator++(); //前置
intPair operator++(int);//后置，int参数无意义

***
# 第9章 字符串
## 字符串类型数组
以'\0'作为结尾的数组中的字符串被称为C字符串。空字符串'\0'也占用一个字节。例如char s[10],只能存储长度不超过9的C字符串变量。一个数组所能存储的字符串的长度将始终比数组的容量少1。
getline函数可以读取整行，用法cin.getline(String_Var, Max_character+1)

## 字符串操作工具
### 成员函数get和put，cin.get(nextSymbol),get可以读取任何字符，包括空格或者'\n'。
陷阱：输入时没有处理'\n',cin>>读完不会跳过'\n',接着用cin.get()读入的会是'\n';

### 成员函数
putback:cin.putback(),将char字符放回输入流
peek:cin.peek()，读取流中的第一个字符但是不会取走。
ignore:cin.ignore(1000,'\n'),忽略流中所有字符，直到遇到'\n'，参数1000是忽略的最大字符数。注：参数并不一定是1000和'\n'

### <cctype>中的常用函数
toupper/tolower
islower 判断是否是小写字母
isalpha 判断是否是字母
isdigit 判断是否是0-9之间的数字
isalnum 判断是否是字母或者数字
isspace 判断表示的字符是否是空白字符（比如空格、换行）
ispunct 判断是否是标点符号
isprint 判断是否是空白以外可打印的
isctrl  判断是否是控制字符

## 标准string类
构造函数默认是空串，可以将C字符串变量初始化为string类，例如string str("hello")或者string str(cString)

### 输入输出
getline: getline(cin,line)

### string类和C字符串的转换
string不能直接转换为C字符串变量，可以显示的调用.c_str()成员函数。

***
# 第10章 指针和动态数组
## 指针
指针本质上是变量的内存的地址
new运算符可以生成一个没有使用标识符命名的变量。new操作时，如果没有足够的内存，在早期编译器中会返回null，在现代编译器中会中断。new运算符创建动态变量时，构造函数会自动调用。
悬空指针（dangling pointer），当对指针delete后，指针所指向的动态变量会被销毁，不过指针变量的值将会指向一个不确定的随机值，程序员应该跟踪悬空指针，并将其赋值为null
typedef int* intPter，不易出错，否则容易漏掉*

## 动态数组
数组变量实际上是一个指针，不能更改数组变量代表的指针变量的值，因为数组变量的类型不是`int*`而是`const int*`.
创建动态数组： `double* d = new double [10];` 动态数组的大小不一定是一个常量，他可以是一个变量。销毁动态数组`delete [] a;   delete a;`无法删除整个数组。
不可返回一个数组类型，但是可以返回指向数组的指针。
指针运算：加法是以一个该类型变量所占的字节长度为单元移动单位的。只有加减法，没有乘除法。指针减法的两个指针必须属于同一个数组，否则没意义。
多维动态数组：`typedef int* intArrayPtr; intArrayPtr *m = new IntArrayPtr[3]; for(int i=0; i<3; ++i) m[i] = new int[4];`

## 类、指针和动态数组
箭头运算符->,它结合了解引用运算符*和点运算符的功能. `p->grade`和`(*p).grade`完全一样。
重载赋值运算符时，需要用this指针特判运算符左右两边是否是同一个对象，否则delete []会出错。
浅拷贝、深拷贝、析构函数。使用默认构造函数时，如果在析构函数中delete []，调用函数会导致内存错误。
三大条原则：拷贝构造函数、赋值运算符及析构函数可以被称作三大条。专家们说如果类的定义中需要三者中的任何一个。

***
# 第11章 分散编译和命名空间
## 分散编译
C++允许一个程序分成不同的部分被写在不同的源文件中。每次编译时，为更改的文件甚至无需重新编译。
### 封装原则
类的说明部分与实现部分分离。
接口实现：

1. 所有的成员变量设为私有成员
2. 所有与该类相关的基本操作都定义为该类的共有成员函数、友元函数、普通函数或者运算符重载
3. 让使用这个类的程序员不能获得这些基本操作的实现的细节

### 头文件和实现文件
inlcude指令必须表明使用头文件是系统的库提供的还是自己编写的，系统是<>，自己写的是“”
程序所在的文件（即包含main函数的文件）通常被成为应用程序文件或者驱动文件
接口文件是不需要直接编译的(.h)
### 连接、连接器
类的实现文件和应用文件编译完成后，还需要将两个文件连接在一起才能使它们正常工作，我们称这个步骤叫做“连接”。在UNIX系统中，通过make工具来完成这些工作。
### 为什么要使用分开的文件
1. 接口文件独立于应用程序文件，使得其他应用程序中方便的使用该类
2. 实现文件只需被编译一次
3. 类有改动时，不必修改使用了这个类的应用程序文件

### 使用#ifndef
避免类的重复定义
{% codeblock lang:cpp%}
#ifndef DTIME_H
#define DTIME_H
<某个类的定义>
#endif
{% endcodeblock %}

## 命名空间
命名空间是一个名称定义的集合。我们编写的任何代码都将属于某个命名空间。如果没有显式地将代码放在任何指定的命名空间，那么代码将处于全局命名空间。
### using指令的作用域
是从using指令出现的位置到语句块结束，如果出现在所有语句块之外，那么该指令将作用域其后的整个文件代码
### 创建命名空间
{% codeblock lang:cpp%}
namespace Name_Space_Name
{
	Some_Code
}
using namespcae Name_Space_Name;
{% endcodeblock %}

一个好的方法是将姓氏或者某个唯一的字符串放在我们定义的命名空间中。
### 无名称的命名空间
编码单元可以是文件，比如类的实现文件。可以使用无名称命名空间将某个名称的定义局限在某个编码单元中。不要混淆全局命名空间和无名称命名空间。在旧版本的C++中，常常使用修饰符static来将一个名称的定义限制在单个文件之内。但这种使用static的用法已经逐渐被淘汰。
隐藏帮助函数的方法：

1. 将帮助函数声明为类的私有成员函数，如果改帮助函数包含对对象的操作，将其设为私有成员函数
2. 将帮助函数放在类实现文件的无名称命名空间中。无需操作对象，放在无名称命名空间中可以避免函数名称修饰符的过多使用

### 应该如何指明使用的命名空间
1. using namespace theSpace; //获取命名空间的所有值
2. using theSpace::f
3. 在所有使用f的地方用theSpace::f代替

***
# 第12章 流和文件I/O操作
程序的输入和输出都是由叫作流的特殊对象实现的。
## I/O流
流就是字符或者其他格式的数据的流动，数据流动方向是进入你的程序，那么叫作输入流，反之流动的方向是由程序向外，那么叫作输出流。
### <fstream>
{% codeblock lang:cpp%}
#include<fstream>
using std::ifstream;
using std::ofstream;
ifstream inStream;
ofstream outStream;
inStream.open("infile.txt");
{% endcodeblock %}
当程序的输入或者输出结束后，必须关闭打开过的文件，关闭文件将断开流对象与文件的关联。
{% codeblock lang:cpp%}
# include<fstream>
inStream.close();
outStream.close();
{% endcodeblock %}

如果程序结束前没有关闭打开的文件，操作系统将会为你自动关闭打开的文件。但是程序员应养成手动关闭的习惯：

1. 操作系统只会在程序正常退出的情况下才会自动关闭文件
2. 在写入文件关闭前，读取该文件。

输出流的成员函数flush()，处于效率考虑，文件的写入过程都使用了缓存，flush可以刷新输出流，将缓存中的数据真正写到磁盘上的文件中。`OutStream.fulsh()`
陷阱：流变量的使用限制，不能使用赋值表达式，流对象做参数时，该参数必须是一个引用参数，而不是一个传值参数。

### 向文件追加输出内容
{% codeblock lang:cpp%}
ofstream outStream;
outStream.open("importan.txt",ios:app);
{% endcodeblock %}

### 检查一个文件是否已经被成功打开
{% codeblock lang:cpp%}
#include<fstream>
inStream.open("infile.txt");
if(inStream.fail()){
	//...
	exit(1)
}
{% endcodeblock %}

## I/O流工具
格式化ostream的输出格式工具

1. setf(ios_Flag)
2. unsetf(ios_Flag)
3. setf(0,ios::floatfield)
4. precision(int)
5. precision()
6. width(int)
7. fill(char)

flags()可以保存格式设置

## 流的继承层次：继承概述
类ifstream是从类istream中派生而来的。

## 随机文件读取
seekp()成员函数

***
# 第13章 递归
在一个函数体内包含对它自身的调用就叫作递归。如果执行过程中遇到一个递归调用，那么函数的执行过程将在此处挂起，因为函数必须要得到递归调用的结果才能继续向下执行。
## 活动帧
这些内存保存了一个函数定义体的引用，一个活动帧包含了足够支持计算机运行的信息。
## 尾递归
大部分编译器会自动将简单地递归函数转换成为等价的迭代版本。使用了尾递归的函数在递归调用发生之后不会在进行进一步的计算。

递归的好处是程序员可以忽略程序运行的细节而让计算机来管理这些细节。但是在相同的计算机系统中，迭代版本的程序运行效率要比递归实现的程序效率高。
