title: 《编程之美读书笔记——第一章游戏之乐》
date: 2015-10-05 07:32:38
categories: Reading
tags: []
---

# 1.1 让CPU占用率曲线听你指挥
开篇第一节略微有点剑走偏锋。关键要搞清楚，Task Manager不可能实时显示CPU占用信息，会有一个采样区间，显示的占用率其实是这段区间内的平均使用率。那么再某个时间片内，分配CPU空闲的比例即可。
CPU空闲可使用Sleep函数，CPU忙使用死循环。
GetTickCount()函数可以获取系统毫秒值。正弦函数曲线只需将连续的sin函数离散化即可。
<!-- more -->

# 1.2 中国象棋将帅问题
基础位运算与C++宏的结合，面试者给出的解法更优美，用int 81代表9*9种局面。个位表示将的9种站位，十位表示帅的9种站位。除三模三就可获得二维坐标。

# 1.3 一摞葱油饼的排序*
Prefix Reversal Sorting问题，易知翻转次数的上限为2(n-1)。由于所求是最少翻转次数，而不是任意一种可行方案。因此利用上下限信息进行回溯搜索。
**正在研究如何DP解决

# 1.4 买书问题
DP问题，F[y1,y2,y3,y4,y5]表示每集有yi本时的最优解，集数顺序无关，y1>=y2>=y3>=y4>=y5，易得转移方程。后文将DP与贪心相结合的部分，行文晦涩没有看懂。

# 1.5 快速找出故障机器
在一个ID集合中，其中有一个ID只出现一次，其余均恰好出现两次，找出出现一次的ID？有两个ID只出现一次。
经典的解法可以用位运算的亦或，只有一个ID时直接与0异或每个ID，最后结果即为所求。两个ID时，第一次异或的结果x，根据x二进制末尾1的情况，对ID集合序列分组。在分得的两组中再进行一次异或即可。
但是如果略作变化，给定两个ID集合，后者在原集合的基础上缺少了2个ID，将这两个ID找出。书中提出了“非变数”概念（台湾版），将原集合ID求sum，可得x+y=a方程，两个未知数还缺一个方程。理论上可用连乘，x*y=b，但在实际中会整数溢出，可改为平方和，x^2+y^2=c。

# 1.6 饮料供货
提供n种饮料，用（Si,Vi,Ci,Hi,Bi）对应名字，容量，可能的最大数量，满意度，实际购买量。在总容量等于V的情况下，求满意度之和最高。DP，f[v,i]表示i,i+1,i+2,...,n-1种饮料中，容量为v时的最大满意度。f[V,0]即为答案。f[v,i] = max(k*Hi+f[v-vi*k,i+1])  (k=0,1,...Ci)，枚举第i种饮料购买个数。
本题特殊的一个条件是，每种饮料的容量都是2的幂次，因此可以根据此条件贪心。

# 1.7 光影切割问题
矩形平面，被若干直线切割后，求平面被划分为几块。（直线无三点共线）
通过分析，划分数目为N+M+1，N是直线数目，M是交点数目。
题目中的直线都是自矩形左边至右边，因此交点数就是逆序数，可用归并或树状数组O(N*logN)求逆序数。
（吐槽一下，Counter-Strike在台湾翻译成《戰慄時空》）

# 1.8 小飞的电梯调度算法
每层会有一定数目的乘客，求电梯停在那层，会让所有乘客总移动距离最小。
最佳化问题，从层数分析，假设楼层总数N，电梯停在x层，要去第i层的乘客数目为Tot[i]，则爬楼总代价为 Sum( Tot[i]*|i-x| )
如果停在第i层的总代价为Y，如果有N1个乘客的目的楼层在i以下，N2个在第i层，N3个在i层以上。那么如果改停在i-1层总代价会发生什么变化?Y-N1+(N2+N3)=Y-(N1-N2-N3);反之改停在i+1层是，总代价为Y+(N1+N2-N3)。由此当N1>N2+N3时停在i-1层更好。当N1+N2<N3时停在i+1层更好，其余留在i层。

# 1.9 高效率的安排说明会*
无向图的最小着色问题，对于土G(E,V),用最少的颜色对定点染色，使得任意(vi,vj)属于E的vi，vj颜色不同。可以从小到大枚举颜色数k，回溯验证。
特殊化的无向图最小着色——最大重叠子区间。给出N条线段，求在何处线段的重叠最多。如果仅求次数，可以将2N个端点分为起点和终点，排序后从小到大扫描，遇到起点+1，终点-1，扫描过程的最大值为所求。求具体方案时，书中给出了O(N^2)，台湾版书中说是可以用heap优化，没看出来如何优化。

# 1.10 双执行绪高效下载
经典的Semaphore读者写者问题，下载与写硬盘两个线程并行。作者分享了他在msra的一个项目，当写硬盘操作过于频繁时，会严重影响用户体验。解决方案时，监听用户鼠标键盘，用户闲时再写硬盘。有点像lazy compile。performance的最高境界，就是把事情做完，同时又不让使用者感觉到程式在费力地做事。

# 1.11 NIM(1) 一排石头的游戏
N块石头排成一行，每块石头有各自固定位置。两人依次取石头，每人每次可以取其中任意一块石头，或者相邻两块，取得最后一块石头的玩家获胜。
博弈游戏要么老老实实的去计算SG，要么有讨巧的方法。这道题就是经典的无赖方法，出去N<2的特殊情况，先手可以必胜。只要先手第一次先去最中间的石头（如果N是偶数，取中间两个）。这样就把问题分解为两个相同的局面，此时无论后手做何种操作，先手再另一个局面模仿即可。只要后手能继续取石头，先手必然可以。N有限的情况下，先手必胜。

# 1.12 NIM(2) 游戏分析
基础NIM游戏，xor，但是要从理论上证明。Game Theory的核心是必胜必败态定义：一个局面的后继节点中有必败态，那么当前节点为必胜态；一个局面的所有后继节点都是必胜态，那么当前节点为必败态。在经典NIM游戏中，如果当前局面的xor和等于0,则为必败态。因为xor为0这个局面，无论进行什么操作都会进入到一个xor不为0的局面（xor不为0是必胜态）。反之，所有xor不为0的局面（必胜态），进行一次操作后，都可以变为xor=0的局面（必败态）。

# 1.13 NIM(3) 
假设有两堆石子，两人轮流取石子，每次可以从一堆取任意个石子，或者从两堆取相等数量的任意个石子，但不能不取。
若先把石子取光的一方为胜方，先取者有什么必胜策略？
若先把石子取光的一方为输方，先取者的策略要进行怎样调整？
SG函数打表找规律，可以得到递推公式，进一步得到通项公式。

# 1.14 连连看游戏设计
游戏设计本质上属于模拟题，代码行数可能较多。需要设计好游戏框架，优化核心算法。
连连看的核心算法是判断两个方格可否消去，根据规则，两个方格能消去的必要条件是，至多拐弯2次。利用BFS搜素即可，每次拓展与当前节点同行同列，不需要拐弯可达的点入队列。

# 1.15 构造数独
随机构造数独大多数情况是无解的，书上说有解的概率是10^-20，先构造一个完整的数独，再挖去几个点，不失为一种好方法。
可以用递归的方法构造数独，用dancing links优化，速度还是很快的。
书中给出了一种置换方法，假设最中间的九宫格，任意填好1-9，其余8个九宫格根据行列变换可以得到完整数独。显然这种构造方法不能构造出所有数独，但是也足够新手练习了。

# 1.16 24点游戏
经典的搜索，书中给出了两种不错的搜索策略，都是分治的思想。
第一种，a b c d四个数种，任选两个数字进行四则运算，将结果与其余两个数组成新集合 x y z，简化问题。但是这种策略未考虑加法交换律等性质，同时有冗余运算。
第二种策略，利用集合论的思想，用int表示二进制的集合信息。集合运算中去重，可以避免很多冗余运算。

# 1.17 俄罗斯方块游戏
经典的模拟，每种形状都用4*4矩阵存储，7种形状4个方向，对应数组BlockSetsp[7][4][4][4]。下落位置可以直接计算，不需要每下降一格重新计算，由于可以落下的最低高度取决于最先接触到已有方格的那一列,min(di-maxRowi) 0<=i<=3
俄罗斯方块简单的AI可以用估价函数的方法实现，

# 1.18 踩地雷游戏*
台湾版的《程式之美》117页是踩地雷游戏的题目描述，118页空白，119页就是第二章数字之魅，不知道是不是印刷有问题。