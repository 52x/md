---
title: Java中访问修饰符和构造函数的一点总结
date: 2016-08-24 21:42:32
tags: [Java]
toc: true
categories: Java平台
---

## Java访问修饰符

|访问修饰符|作用范围|
|---|---|
|public| 完全开发|
|private|只能本类访问|
|protected|同包及子类访问|
|default(无修饰符时)|同包访问|

## Java用于类的修饰符（2个）和限定符（2个）

|访问修饰符|作用范围|
|---|---|
|public| 完全开发|
|default(无) |同包访问|

> 注意：内部类可以拥有更多的访问修饰符

<!--more-->

----------

|限定符|描述|
|---|---|
|abstract|指定为抽象类|
|final|指定为最终类，不可被继承|

## Java用于成员变量的修饰符

- public
- protected 
-  private 
- static 
- final
- transient 
- volatile

限定词含义：
|限定符|描述|
|---|---|
|static| 类属性，可通过类名直接调用|
|final|该成员不能被重写，即定义常量|
|transient| 不序列化|
|volatile |可被多个线程访问 （同步变量）|


## Java用于成员方法的修饰符

- public
- protected 
-  private 
- static 
- final
- abstract
- native
- synchronized

限定词含义：
|限定符|描述|
|---|---|
|static|类(静态)方法，可通过类名直接调用|
|final|方法不能被重写|
|native| 集成其它语言的代码 本地方法|
|abstract|抽象方法，没有方法体|
|synchronized|控制多个并发线程的访问 （同步方法）|

## 构造函数的一些注意事项

> 在 Java 中，无论是 explicit 还是 implicit 方式，都要求在子类的构造方法中调用其父类的构造方法。

如果父类无构造方法（其实是一个默认无参的构造方法），那么子类的构造方法中会自动进行调用；如果 父类有自己的构造方法（这时父类不会有默认无参的构造方法），那么在子类的构造方法中，必须要调用父类的某个构造方法，而且必须是在构造方法的第一个语句 中进行调用。 究其原因，想必是 Java 语言设计者，要求子类有责任保证它所继承的父类尽快进入到一个稳定、完整的状态中。试想，如果没有这个约束，那么子类的某个继承自父类的方法可能会使用到父类中的一些变量，而这些变量并没有进行初始化，从而产生一些难以预料的后果。 

- 构造函数必须满足的语法规则：方法名必须与类名相同；不要声明返回类型；不能被static、final、synchronized、abstract、native等修饰。

- 构造方法可以被重载，来表达对象的多种初始化行为。在重载构造方法中可以使用this语句来调用其他构造方法，使用时应该注意：如果在构造方法中使用了this语句，则必须作为构造方法的第一条语句；只能在一个构造方法中用this语句来调用类的其他构造方法，而不能在成员方法中调用类的构造方法；只能通过this语句来调用其他构造方法，不能通过方法名来直接调用构造方法。

- 在java中，如果用户定义的类中没有提供任何构造方法，java语言会自动提供一个默认的构造方法，该默认构造方法没有参数，用public修饰，且方法体为空。当然，程序中也可以显示的定义默认构造方法。

- 如果类中显示定义了一个或多个构造方法，并且所有的构造方法都带有参数，那么这个类就失去了java语言为其准备的默认构造方法，此时若使用该类的默认构造方法（即不含参数的构造方法）时就是编译出错。

- 父类的构造方法不能被子类继承，但是，在子类的构造方法中可以通过super语句调用父类的构造方法。使用super语句应该注意：在子类的构造方法中使用super语句，它必须作为第一条语句。

- 在创建子类的对象时，java虚拟机首先执行父类的构造方法，然后再执行子类的构造方法，在多级继承的情况下，将从继承树的最上层得父类开始，依次执行各个类的构造方法，这可以保证子类对象从所有直接或间接父类中继承的实例变量都被正确的初始化。

- 如果子类的构造方法中没有用super语句显示调用父类的构造方法，那么通过这个构造方法创建子类对象时，java虚拟机会自动先调用父类的默认构造方法，而此时若父类没有默认构造方法时，就是编译出错。
例如

```
class A //该类定义了含参数的构造方法，就失去了默认的无参的构造方法
{

    int i;

    A(int i) {

        this.i=i*2;

    }

}
public class B extends A
{

    B(int i) {//该构造方法没有super显示调用父类的构造方法，将自动调用父类的默认构造方法，而父类A没有默认构造方法，这里将编译错误

        System.out.println(i);

    }

    public static void main(String[] args) {

        B b=new B(2);

    }

}
``` 

- 构造方法被调用的几种方式：
 - 当前类的其他构造方法通过this语句调用它；
 - 当前类的子类的构造方法通过super语句调用它；
 - 在程序中通过new语句调用它。

- 构造方法可以处于public、protected、private和默认四种访问级别之一。当构造方法为private级别时，意味着只能在当前类访问它，不能被继承，不能被其他程序用new创建实例对象。可以对比其他几种修饰符的作用：abstract修饰的类，不允许被实例化，这点和private修饰构造方法相同，但abstract修饰的类可以被继承，拥有子类，可以创建子类的实例；final类禁止被继承，这点和private修饰构造方法相同，但是final类可以用new创建实例对象。
