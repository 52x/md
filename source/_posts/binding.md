---
title: 驱动模型之驱动绑定
tags:
  - 设备模型
categories:
  - Kernel
  - 内核文档
date: 2014-03-05 14:58:34
---

翻译原文链接：<http://m.blog.csdn.net/blog/guoshaobei/4917225>
内核文档：Documentation/driver-model/binding.txt
<!--more-->

驱动绑定就是将一个设备和控制该设备的驱动关联在一起的过程。典型的情况下，总线驱动来处理驱动绑定，因为每个总线驱动都有总线相关的数据结构来表示设备和设备驱动。有了表示设备和设备驱动的通用数据结构，绝大多数的绑定过程可以使用这些通用代码。

**总线**

总线类型数据结构包含一个记录所有属于这个总线类型的设备链表。当一个设备驱动调用`device_register()`时，它会被添加到这个链表的尾部。总线类型数据结构也包含一个记录所有属于这个总线类型的驱动链表。当一个设备驱动调用`driver_register()`时，该驱动会被添加到这个链表的尾部。这是触发驱动绑定的两个主要事件。

**设备注册**

当一个新设备被添加后，总线的驱动链表会被迭代，查找出支持该设备的驱动。为了达到这个目的，新设备的设备ID必须匹配驱动支持的设备ID中的一个。设备ID的格式和语法是总线相关的。不需要使用一个复杂的状态机和匹配算法，而是由总线驱动提供一个`callback`函数来比较设备和一个驱动所支持的ID是否匹配，如果匹配返回值为1，否则返回值为0。
```c
int match(struct device * dev, struct device_driver * drv);
```
当一个匹配被找到时，设备的'`driver`'域会被设置为这个驱动，驱动的`probe`回调函数会被调用。这使驱动有机会检验是否真正支持这个硬件设备,同时会检验设备是否处于工作状态。

**设备类别**

当`probe`成功完成后，设备被注册到它属于的类中。设备驱动属于且仅属于一个类，这个类会在驱动的`devclass`域中设置。`devclass_add_device`被调用来枚举和注册类中的设备，这个过程发生在类的`register_dev`回调函数中。

注意：设备`class`结构和其核心操作函数还没有进入mainline内核，所以以上讨论有一定推测性。

**驱动**

当一个驱动被关联到一个设备时，这个设备被插入到驱动的设备链表中。

**sysfs**

在`bus`目录的'`devices`'子目录里，创建符号链接，指向实际的`device`目录。

在`driver`的'`devices`'子目录里，创建符号链接，指向实际的`device`目录。

在`class`目录里为设备创建子目录，在子目录里，创建符号链接，指向该设备在sysfs tree里的实际位置。

也可以在设备的实际目录里，创建符号链接，指向它的`class`目录，或者`class`目录的顶层目录；也可以创建符号链接，指向它的`driver`目录。不过目前并没有这样做。

**驱动注册**

添加一个新的`driver`的过程，与添加一个新的`device`的过程类似。总线的设备链表会被迭代，找到一个匹配的设备。已经绑定在驱动上的设备可以被跳过。所有的设备都要被迭代，多个设备可以绑定到一个驱动上。

**删除**

当一个设备要被删除时，它的引用计数最终会为0。当为0时，驱动的`remove`回调函数会被调用。设备会从驱动的设备链表中移除，驱动的引用计数会减1。设备和它的驱动之间的符号链接均被删除。

当一个驱动要被删除时，它所支持的设备列表会被迭代，驱动的`remove`回调函数会为每一个设备调用一次。设备从设备列表中删除，符号链接也要被删除。
