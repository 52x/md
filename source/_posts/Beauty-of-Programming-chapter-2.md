title: 《编程之美读书笔记——第二章数字之魅》
date: 2015-10-05 08:32:38
categories: Reading
tags: []
---
# 2.1  求二进位数字中1的个数
v&(v&1)可以消去二进位中最后一个1
case穷举法
打表法
<!-- more -->
# 2.2 不要被阶乘吓到 *
N!末尾有多少个0？
十进制中只有2*5会产生0，本质是求1-N中素因子5的个数。

N/5+N/5^2+N/5^3+...
while(N){
	ret+=N/5;
	N/=5;
}

N!的二进位表示中最低位元1的位置，等同于N!含有质因数2的个数，同上。

书后附了一个blog，里面有更快地算法，但是csdn的架构可能改了，网站打不开。

# 2.3 寻找贴文发帖王*
在ID集合中，有一个ID出现次数超过一半，找出这个ID。
分治的思想，如果每次删去两个不同的ID，那么剩下的集合中，目标ID的个数依然超过一半。因此每次删掉两个不同ID，剩下的即为所求，O(N)扫一遍即可。
*扩展
如果有3个ID，他们的出现次数超过总数的1/4，请找出这3个ID。
进一步，如果有k个ID，他们的出现次数超过总数的1/(k+1),请找出这4个ID。

# 2.4 1的数目 *
给定一个十进制正整数N，写下从1开始，到N的所有整数，然后数一下其中出现的所有“1”的个数。
试着写几个数，然后发现规律，分类讨论各种情况。复杂度logN(即N的位数)

当前位是0，考虑高位
当前位是1，考虑高位和低位
当前位大于1，考虑高位

也可以进行数位DP*，最水的数位DP

# 2.5 寻找最大的K个数
从n个数中找出最大的k个数。
严格的从图灵机的角度来说，任何算法的复杂度至少是O(N)。因此题目可以变形为，寻找第k大数，然后O(N)扫描一次，即可得到前K大。
第k大数问题很经典，可以利用快排的思路，平均复杂度线性，同时也有线性的算法可以解决。

如果当n海量时，无法在内存中计算，可以利用heap来存储最大的k个数，遍历这N个数的同时维护heap。

# 2.6 精确表达浮点数
将形如0.333(3)  0.5  0.12(34)的小数转换成对应的最简分数形式。

基础的数学推导，一步步简化，转化问题即可。

首先忽略整数为，只考虑X<1的情况。

大情况分为有限小数和无限小数。
一、有限小数，显然这类情况相对简单，X=0.a1a2a3...an时X = a1a2a3...an/10^n，铜粉即可
二、无限小数，X = 0.a1a2...an（b1b2...bm），最复杂的莫过于同时又非循环部分与循环部分，经过简单转换可以将循环部分挪到整数位上
 	X*10^n = a1a2...an+0.(b1b2...bm)
	X = (a1a2...an+0.(b1b2...bm))/10^n
	现在只需要专心讨论0.(b1b2...bm)，令Y=0.(b1b2...bm)，那么
	10^m * Y = b1b2...bm+0.(b1b2...bm)
	10^m * Y - Y = b1b2...bm
	Y = b1b2...bm/(10^m - 1)
	将Y代入X的表达式，整理可得
	((a1a2...an)*(10^m - 1)+(b1b2...bm))/((10^m - 1) * 10^n)

此题的关键是将复杂问题简单化

拓展：将分数形式转换为循环小数形式，方式是不断除，寻找余数的循环节。

# 2.7 最大公约数问题
解法一：欧几里得辗转相除法f(x,y) = f(y,y%x)，用到了取余运算，对于大整数来说，除法代价太高。
解法二：将除法换为减法f(x,y) = f(x-y,y),对于f(10000000000,1)这类数据运算次数过多
解法三：综合一、二解法，对于x和y来说，如果k是x和y的公因子，那么有f(x,y)=k*f(x1,y1)。另外如果对于质数p，x=p*x1且y%p!=0,那么f(x,y)=f(p*x1,y)=f(x1,y)。根据以上两点，我们用质数2来操作，因为位移操作可以达到除以2的效果，避免除法。
若x,y均为偶数，f(x,y) = 2*f(x>>1,y>>1)
若x为偶数，y为奇数，f(x,y) = f(x>>1,y)
若x为奇数，y为偶数，f(x,y) = f(x,y>>1)
若x,y均为奇数，f(x,y) = f(y,x-y) 由于x、y为奇数，那么x-y必为偶数，下一步会有除2操作
最坏情况下复杂度O(log(max(x,y)))

# 2.8 找符合条件的整数
任意给定一个正整数N，求一个最小的正整数M(M>1)，使得N*M的十进制表示形式里只含有0和1。
直接的想法是从小到大枚举M，这样效率很低而且不能保证一定能退出循环。
稍作转换，由于N M都是正整数，所以求M最小也是求N*M，本题可以变为求最小的X，X的十进制形式只有0和1且X整除N。X可以只存储1出现的位置。
X取值从小到大依次是1、10、11、100其实就是二进制从小到大，直接遍历X如果X的结果有K位，则要循环2^k。由于我们要找最小的X，使得XmodN=0，因此只要记录modN=i(0<=i<N)的最小X即可。
假设已经计算出X的十进制有K位时的情况，现在要计算K+1位的情况，即X=10^k+Y(0<Y<10^k)。如果用暴力的方法，搜索空间是2^k - 1。但是我们可以把Y按照X%N进行分组，最多N组，因此搜索空间变为N。所以总复杂度为(K-1)*N，K是结果的位数。

# 2.9 费伯纳西（Fibonacci）数列
构造转移矩阵A，初始向量(f0,f1)*A^(n-1)，用快速幂求矩阵次方。

# 2.10 寻找阵列中的最大值和最小值
对于一个由N个整数组成的阵列，需要比较多少次，才能把最大和最小的数找出来？
直接独立来做，扫描两次，比较2*N次。
用分治的方法来做f(N) = 2*f(N/2)+2 = 1.5N-2

# 2.11 寻找最近点对
分治法，将坐标点排序后，分成left、right两部分。最近点对要么只在left或right集合中，或者跨立left和right集合。第一种情况简单，对于其中一个点来自left另一个点来自right的情况。做如下分析
MDist = Min( MinDist(left),MinDist(right) ),根据鸽笼原理，在MinDist*(2*Mdist)的区域内最多有8个点，对于在[x-d,x+d]内的点按照y排序，每个点只需要计算紧邻的7个点即可。因此复杂度f(N) = 2*f(N/2) + O(N) = N*logN
http://www.cnblogs.com/AdaByron/archive/2011/10/07/2200966.html 

# 2.12 快速寻找满足条件的两个数
快速寻找一个阵列中的两个数字，让这两个数字之和等于一个给定的数字。
two pointer扫描，O(N)

# 2.13 子阵列的最大乘积
给定一个长度为N的整数阵列，只允许用乘法，不能用除法，计算人意(N-1)个数的组合乘积中最大的一组。
最直观的十求N个数的累乘记作S，用S除以A[i]，取最大值即可，但是题目要求不能用除法。
解法一：用两个数组，s[i],t[i]，s[i]是从A[0]到A[i-1]的累乘，t[i]是从A[N-1]到A[i+1]的累乘，那么除了S/A[i] = s[i]*t[i]，时间复杂度O(N)，但是要使用额外的空间。
解法二：讨论N个数累乘的S的奇偶性。
S为0，如果只有1个0，那么去除0之后的乘积与0取最大值，超过1个0则结果为0
S为负数，去掉绝对值最小的负数
S为正数，如果全为负数，则答案为0，如果有整数，去掉绝对值最小的正数。
在代码实现中，不需要真的求出S，只需要分别记录负数、0、正数的个数即可。

# 2.14 求阵列的子阵列之和的最大值
基础DP

# 2.15 子阵列之和的最大值（二维）
枚举[i,j]行，将这j-i+1压缩为一行，转化成一维问题，时间复杂度为O(N*M*min(N,M))。

# 2.16 求阵列中最长递增子序列*
定义前i个元素中的最长递增子序列为LIS[i],那么DP转移为LIS[i+1] = max{1,LIS[k]+1},array[i+1]>array[k],k<=i，时间复杂度为O(N^2)。
解法二，在上面的解法上，再定义长度为i的递增子序列最大元素的最小值是MaxV[i]
for(j=LIS[i-1];j>=1;j--){
	if(array[i]>MaxV[j]){
		LIS[i] = j + 1;
		break;
	}
}
在递增序列中，如果i<j，那么就会有MaxV[i]<MaxV[j]，如果出现MaxV[i]>MaxV[j]
会矛盾，根据此性质二分，复杂度会将为O(N*logN)

# 2.17 阵列回圈移位元
把一个含有N个元素的阵列回圈右移K位元。
12345678，移动3位后变为
67812345，可以发现678与12345两个部分，内部顺序不变，只是两部分调换位置，因此可以先把这两个部分内部reverse，再将整个数组reverse。
12345678->54321876->67812345
时间复杂度O(N)

# 2.18 阵列分割
有一个没有排序、元素个数为2n的正整数阵列，如何把这个阵列分割为元素个数为n的两个阵列，并使这两个子阵列的和最接近。
DP，f[j][k]是否可以可以找到j个数和为k。复杂度为O(N^2*SUM)

# 2.19 区间重合判断
给定一个来源区间[x,y]和N个无序的目标区间[x1,y1],[x2,y2]...[xn,yn],判断来源区间[x,y]是不是在目标区间内。
先将N个目标区间排序，然后合并，之后在二分判断来源区间即可。复杂度为O(N*logN)

# 2.20 程式理解和时间分析
给一段代码，分析这段代码的功能以及时间复杂度。

# 2.21 只考加法的面试题
问题1，写一个程式，对于一个64为正整数，输出它所有可能的连续自然数（两个以上）之和的算式
问题2，什么样的数，不能分解为两个以上的连续自然数。
问题3，64位以内的整数，哪个数的分解算式最多。

将一个正整数表示成连续自然数之和，即N=s+(s+1)+(s+2)+…+(e-1)+e。利用等差数列求和公式，我们有
N = （s+e)*(e-s+1)/2
2N = （s+e)*(e-s+1) 设x = s+e , y = e-s+1
可以解得 s = (x-y+1)/2  e = (x+y-1)/2,为满足整除，x,y必须一奇一偶，又因为2N=xy,2N含有偶因子，所以N必须含有奇因子才能成立，第一问的充要条件就是N含有奇因子。




